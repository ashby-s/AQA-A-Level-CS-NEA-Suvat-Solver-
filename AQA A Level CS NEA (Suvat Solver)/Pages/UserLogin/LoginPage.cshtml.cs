using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using AQA_A_Level_CS_NEA__Suvat_Solver_.Models;
using AQA_A_Level_CS_NEA__Suvat_Solver_.Data;
using System.Security.Cryptography;
using System.Text;

namespace AQA_A_Level_CS_NEA__Suvat_Solver_.Pages.UserLogin
{
    [BindProperties(SupportsGet = true)]
    public class LoginPageModel : PageModel
    {
        public string TempUsername { get; set; }
        public string TempPassword { get; set; }
        public bool HasPassword { get; set; } = true;
        public bool HasUsername { get; set; } = true;
        public bool ValidationFailed { get; set; }

        public bool RegisterApproved { get; set; }

        private readonly ApplicationDbContext _context;
        public LoginPageModel(ApplicationDbContext context)
        {
            _context = context;
        }

        public IActionResult OnPost()
        {
            HasPassword = true;
            HasUsername = true;
            ValidationFailed = false;
            string HashedPassword = "";

            //Checks whether username is valid
            if (string.IsNullOrWhiteSpace(TempUsername))
            {
                HasUsername = false;
            }

            //Checks whether password is valid
            if (string.IsNullOrWhiteSpace(TempPassword))
            {
                HasPassword = false;
            }
            else
            {
                //hashes entered password to be checked
                HashedPassword = HashPassword(TempPassword);
            }

            //checks if there is a value for username where password is correct from database value
            var foundUser = _context.User.FirstOrDefault(x => x.UserName == TempUsername && x.UserPass == HashedPassword);

            //checks if credentials were incorrect
            if (foundUser == null && HasPassword == true && HasUsername == true)
            {
                ValidationFailed = true;
            }

            //If anything was not how it is meant to be, the page will refresh
            //with corresponding errors being passed and shown
            if (!HasPassword || !HasUsername || foundUser == null)
            {
                return RedirectToPage("/UserLogin/LoginPage", new { HasPassword, HasUsername, ValidationFailed });
            }
            else
            {
                //If correct, sends over to home logged in page
                return RedirectToPage("/Home-LoggedIn", new { foundUser.UserId });
            };
        }
        public string HashPassword(string Password)
        {
            char CurrentChar;
            byte CharVal;
            byte NewCharVal = 0;
            char NewChar;
            string HashedPassword = "";
            int iRepeat = 0;

            for (int i = 0; i < 32; i++)
            {
                //gets each character of password and converts it to a byte value
                if (i >= Password.Length)
                {
                    //ensures that hashed value is 32 chars long, so goes through chars again
                    if (iRepeat >= Password.Length)
                        iRepeat = 0;
                    CurrentChar = Password[iRepeat];
                    iRepeat++;
                }
                else
                {
                    CurrentChar = Password[i];
                    iRepeat++;
                }

                //updates the generated byte value
                CharVal = (byte)CurrentChar;
                CharVal = (byte)(CharVal - i + (3 * iRepeat));
                //gets a new byte value, with adding or subtracting from old value
                switch (CharVal % 10)
                {
                    case 0:
                        NewCharVal = (byte)(CharVal - 17);
                        break;
                    case 1:
                        NewCharVal = (byte)(CharVal - 4);
                        break;
                    case 2:
                        NewCharVal = (byte)(CharVal - 15);
                        break;
                    case 3:
                        NewCharVal = (byte)(CharVal - 13);
                        break;
                    case 4:
                        NewCharVal = (byte)(CharVal - 9);
                        break;
                    case 5:
                        NewCharVal = (byte)(CharVal - 8);
                        break;
                    case 6:
                        NewCharVal = (byte)(CharVal - 10);
                        break;
                    case 7:
                        NewCharVal = (byte)(CharVal - 12);
                        break;
                    case 8:
                        NewCharVal = (byte)(CharVal - 16);
                        break;
                    default:
                        NewCharVal = (byte)(CharVal + 3);
                        break;
                }
                //converts value back into a character, and to a string
                NewChar = ((char)NewCharVal);
                HashedPassword = HashedPassword + NewChar;
            }
            //sends hashed password back
            return HashedPassword;
        }
    }
}
